# PDF Summarizer Web Application

## Overview
The PDF Summarizer Web Application is a user-friendly tool that allows users to upload PDF documents or paste text for summarization. It utilizes modern web technologies to provide a seamless experience, including a loading feature to enhance user interaction. This project is designed to help users quickly extract essential information from lengthy documents or text.

## Context 
We will be using Google's PEGASUS from the transformer library of hugging face (open-source NLP models)

## Technologies Used
HTML: For structuring the web page.
CSS: For styling and making the application visually appealing.
JavaScript: For handling user interactions and making API requests.
FastAPI: A modern web framework for building APIs with Python.
Fetch API: To handle asynchronous requests to the backend.
FormData: To manage file uploads and data submission in a user-friendly way.


## Key Features
PDF Upload: Users can upload a PDF file, and the application will summarize its content based on the selected length (short, medium, long). **Issue to fix**

Text Input: Users can also paste text directly into a text area for summarization.
Loading Indicator: A loading spinner provides feedback to users while their requests are being processed.

Responsive Design: The application is designed to work seamlessly on various screen sizes.

## What I Learned
Throughout the development of this application, I learned:

How to integrate a front-end interface with a back-end API using JavaScript's Fetch API.
The importance of user feedback through loading indicators and responsive design to improve user experience.

How to handle file uploads and JSON data within web forms effectively.
Best practices for organizing code and keeping it modular for maintainability and scalability.

## Issues encountered and solutions
1. Tokenization Errors During Summarization:
**Issue**: While developing the summarization model, I encountered errors related to the input text tokenization, which often led to exceptions during the summarization process. The model struggled with properly segmenting and processing the input text, resulting in failed summarization attempts.
**Solution**: To mitigate these issues, I implemented the SentencePiece tokenizer, which improved the handling of input text by providing more efficient tokenization. This change allowed the model to process the input more accurately and reduced the frequency of errors during summarization.

2.Challenges with Multi-Part File Uploads in FastAPI:
**Issue**: During the implementation of file uploads, I faced challenges related to multi-part requests in FastAPI. Uploading larger PDF files occasionally resulted in timeouts or incomplete reads of the uploaded content, causing the application to fail in processing the file.
**Solution**: I addressed this issue by utilizing FastAPIâ€™s UploadFile class, which enabled asynchronous handling of file uploads. Additionally, I configured appropriate request size limits within FastAPI to ensure that larger files could be uploaded without timing out. This significantly improved the reliability of the file upload process and enhanced user experience.


3. CORS Error Due to Different Domains:
**Issue**: While testing the application, I encountered Cross-Origin Resource Sharing (CORS) errors due to the FastAPI backend and HTML frontend being served from different domains. This prevented the frontend from making requests to the backend, blocking the intended functionality.
**Solution**: I resolved this issue by configuring CORS middleware in FastAPI to allow requests from all origins during development. This setup enabled seamless communication between the frontend and backend without CORS-related interruptions.

4. Max Input Limit of 512 Tokens:
**Issue**: The PEGASUS model has a maximum input limit of 512 tokens, which resulted in awkward truncation of longer texts during summarization. This often led to incomplete or unclear summaries, diminishing the effectiveness of the application.
**Solution**: To address this limitation, I implemented a strategy to appropriately split the input text into individual segments that fit within the token limit. After processing these segments separately, I merged the results into a cohesive final summary. This approach significantly improved the quality of the summaries generated by the application.


## Future Improvements
While the application is functional, there are several areas for future improvement:

Enhanced Error Handling: Implement more robust error handling to manage different scenarios, such as network issues or unsupported file types.
Summary Quality: Investigate and integrate more advanced summarization algorithms or natural language processing (NLP) models to improve the quality of the summaries generated.

User Authentication: Consider adding user authentication to allow users to save and manage their previous summaries.

Mobile Optimization: Further optimize the user interface for mobile devices, ensuring usability and accessibility.

Testing: Implement unit and integration tests to ensure the reliability and stability of the application.

Deployment: Host the application on a cloud platform (e.g., Heroku, AWS) for wider accessibility.

## Installation

To run this project locally, follow these steps:

1. Clone the repository:
```bash
git clone https://github.com/3lson/pdf-summarizer.git
cd pdf-summarizer
```

2. Install FastAPI and other required packages: 
```bash
pip install fastapi uvicorn
```

3. Start the FastAPI server
```bash
uvicorn app:app --reload
```

4. Open your web browser and navigate to http://127.0.0.1:8000.

## Conclusion
The PDF Summarizer Web Application is a practical project that highlights the intersection of front-end and back-end development. It provides a solid foundation for further exploration into web applications, summarization techniques, and user experience design.

Feel free to explore the code, contribute, or suggest improvements!